import { Command, Parameter } from '@/types/schema';

type GeneratedFile = {
  path: string;
  content: string;
};

export function generateCode(
  commands: Record<string, Command>,
  rootId: string
): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  // 1. types.ts
  const typesContent = generateTypes(commands);
  files.push({ path: 'src/types.ts', content: typesContent });

  // 2. interfaces.ts
  const interfacesContent = generateInterfaces(commands);
  files.push({ path: 'src/interfaces.ts', content: interfacesContent });

  // 3. cli.ts
  const cliContent = generateCLI(commands, rootId);
  files.push({ path: 'src/cli.ts', content: cliContent });

  return files;
}

function generateTypes(commands: Record<string, Command>): string {
  let content = `/**
 * This file is auto-generated by CLI Maker.
 * Do not edit manually.
 */\n\n`;

  Object.values(commands).forEach((cmd) => {
    const interfaceName = `${toPascalCase(cmd.name)}Params`;
    content += `export interface ${interfaceName} {\n`;
    
    // Arguments
    cmd.parameters.filter(p => p.kind === 'argument').forEach(p => {
        const type = p.type === 'boolean' ? 'boolean' : p.type === 'number' ? 'number' : 'string';
        const optional = !p.required ? '?' : '';
        content += `  ${toCamelCase(p.name)}${optional}: ${type};\n`;
    });

    // Options
    cmd.parameters.filter(p => p.kind === 'option').forEach(p => {
        const type = p.type === 'boolean' ? 'boolean' : p.type === 'number' ? 'number' : 'string';
        const optional = !p.required ? '?' : '';
        content += `  ${toCamelCase(p.name)}${optional}: ${type};\n`;
    });

    content += `}\n\n`;
  });

  return content;
}

function generateInterfaces(commands: Record<string, Command>): string {
  let content = `import * as Types from './types';\n\n`;
  content += `export interface AppHandler {\n`;

  Object.values(commands).forEach((cmd) => {
      if (!cmd.handlerName) return;
      const paramType = `Types.${toPascalCase(cmd.name)}Params`;
      content += `  ${cmd.handlerName}(params: ${paramType}): Promise<void>;\n`;
  });

  content += `}\n`;
  return content;
}

function generateCLI(commands: Record<string, Command>, rootId: string): string {
  const root = commands[rootId];
  
  let content = `import { Command } from 'commander';
import { AppHandler } from './interfaces';

export function setupCLI(handler: AppHandler) {
  const program = new Command();
  
  program
    .name('${root.name}')
    .description('${root.description || ''}')
    .version('0.0.1');\n\n`;

  // Recursive function to build commands
  const buildCommand = (cmdId: string, parentVar: string) => {
      const cmd = commands[cmdId];
      if (!cmd) return;

      // If root, we attach to 'program', but root usually doesn't have its own command string in commander if it's the entry point.
      // However, for subcommands, we need .command().
      // For the root command itself, we might want to define action if it has no subcommands or if we want a default action.
      
      // Let's assume root command is the program itself.
      // Subcommands are added to it.
      
      if (cmdId === rootId) {
          // Root command configuration (already done name/desc)
          // Add root options/args
          addParams(cmd, 'program');
          
          // If root has handler and no subcommands (or we want default action), add action
          if (cmd.handlerName) {
             addAction(cmd, 'program');
          }
          
          // Process children
          cmd.subcommands.forEach(childId => buildCommand(childId, 'program'));
      } else {
          const varName = `cmd_${cmd.id.replace(/-/g, '_')}`;
          const args = cmd.parameters.filter(p => p.kind === 'argument')
            .map(p => p.required ? `<${p.name}>` : `[${p.name}]`)
            .join(' ');
            
          content += `  const ${varName} = ${parentVar}.command('${cmd.name}${args ? ' ' + args : ''}');\n`;
          if (cmd.description) {
              content += `  ${varName}.description('${cmd.description}');\n`;
          }
          
          addParams(cmd, varName);
          
          if (cmd.handlerName) {
              addAction(cmd, varName);
          }
          
          cmd.subcommands.forEach(childId => buildCommand(childId, varName));
          content += `\n`;
      }
  };

  const addParams = (cmd: Command, varName: string) => {
      cmd.parameters.filter(p => p.kind === 'option').forEach(p => {
          const flags = `-${p.shortAlias || p.name.charAt(0)}, --${p.name} ${p.type === 'boolean' ? '' : `<${p.type}>`}`;
          const desc = p.description || '';
          const required = p.required ? '' : ''; // Commander handles required differently, usually .requiredOption
          // Simple option for now
          content += `  ${varName}.option('${flags}', '${desc}');\n`;
      });
  };

  const addAction = (cmd: Command, varName: string) => {
      // Construct params object
      // Commander passes args first, then options object, then command object.
      // We need to map these to our Params interface.
      const args = cmd.parameters.filter(p => p.kind === 'argument');
      const argNames = args.map(p => toCamelCase(p.name));
      const actionArgs = [...argNames, 'options'].join(', ');
      
      content += `  ${varName}.action(async (${actionArgs}) => {\n`;
      content += `    const params = {\n`;
      
      // Map arguments
      args.forEach(p => {
          const name = toCamelCase(p.name);
          const val = p.type === 'number' ? `Number(${name})` : name;
           content += `      ${name}: ${val},\n`;
      });
      
      // Map options
      cmd.parameters.filter(p => p.kind === 'option').forEach(p => {
          const name = toCamelCase(p.name);
           const val = p.type === 'number' ? `Number(options.${name})` : `options.${name}`;
           content += `      ${name}: ${val},\n`;
      });
      
      content += `    };\n`;
      content += `    await handler.${cmd.handlerName}(params);\n`;
      content += `  });\n`;
  };

  buildCommand(rootId, 'program');

  content += `  return program;\n}\n`;
  return content;
}

// Helpers
function toCamelCase(str: string) {
  return str.replace(/[-_](\w)/g, (_, c) => c.toUpperCase());
}

function toPascalCase(str: string) {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}
