import { Command, Parameter } from '@/types/schema';

type GeneratedFile = {
  path: string;
  content: string;
};

export function generateCode(
  commands: Record<string, Command>,
  rootId: string
): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const rootCommand = commands[rootId];

  // 1. types.ts
  const typesContent = generateTypes(commands);
  files.push({ path: 'src/types.ts', content: typesContent });

  // 2. interfaces.ts
  const interfacesContent = generateInterfaces(commands);
  files.push({ path: 'src/interfaces.ts', content: interfacesContent });

  // 3. cli.ts
  const cliContent = generateCLI(commands, rootId);
  files.push({ path: 'src/cli.ts', content: cliContent });

  // 4. handler.ts (dummy implementation)
  const handlerContent = generateHandlerImplementation(commands);
  files.push({ path: 'src/handler.ts', content: handlerContent });

  // 5. index.ts (entry point)
  const indexContent = generateIndexFile(rootCommand);
  files.push({ path: 'src/index.ts', content: indexContent });

  // 6. package.json
  const packageJsonContent = generatePackageJson(rootCommand);
  files.push({ path: 'package.json', content: packageJsonContent });

  // 7. tsconfig.json
  const tsconfigContent = generateTsConfig();
  files.push({ path: 'tsconfig.json', content: tsconfigContent });

  // 8. README.md
  const readmeContent = generateReadme(commands, rootCommand);
  files.push({ path: 'README.md', content: readmeContent });

  // 9. .gitignore
  const gitignoreContent = generateGitignore();
  files.push({ path: '.gitignore', content: gitignoreContent });

  return files;
}

function generateTypes(commands: Record<string, Command>): string {
  let content = `/**
 * This file is auto-generated by CLI Maker.
 * Do not edit manually.
 */\n\n`;

  Object.values(commands).forEach((cmd) => {
    const interfaceName = `${toPascalCase(cmd.name)}Params`;
    content += `export interface ${interfaceName} {\n`;
    
    // Arguments
    cmd.parameters.filter(p => p.kind === 'argument').forEach(p => {
        const type = p.type === 'boolean' ? 'boolean' : p.type === 'number' ? 'number' : 'string';
        const optional = !p.required ? '?' : '';
        content += `  ${toCamelCase(p.name)}${optional}: ${type};\n`;
    });

    // Options
    cmd.parameters.filter(p => p.kind === 'option').forEach(p => {
        const type = p.type === 'boolean' ? 'boolean' : p.type === 'number' ? 'number' : 'string';
        const optional = !p.required ? '?' : '';
        content += `  ${toCamelCase(p.name)}${optional}: ${type};\n`;
    });

    content += `}\n\n`;
  });

  return content;
}

function generateInterfaces(commands: Record<string, Command>): string {
  let content = `import * as Types from './types.js';\n\n`;
  content += `export interface AppHandler {\n`;

  Object.values(commands).forEach((cmd) => {
      if (!cmd.handlerName) return;
      const paramType = `Types.${toPascalCase(cmd.name)}Params`;
      content += `  ${cmd.handlerName}(params: ${paramType}): Promise<void>;\n`;
  });

  content += `}\n`;
  return content;
}

function generateCLI(commands: Record<string, Command>, rootId: string): string {
  const root = commands[rootId];
  
  let content = `import { Command } from 'commander';
import { AppHandler } from './interfaces.js';

export function setupCLI(handler: AppHandler) {
  const program = new Command();
  
  program
    .name('${root.name}')
    .description('${root.description || ''}')
    .version('0.0.1');\n\n`;

  // Recursive function to build commands
  const buildCommand = (cmdId: string, parentVar: string) => {
      const cmd = commands[cmdId];
      if (!cmd) return;

      // If root, we attach to 'program', but root usually doesn't have its own command string in commander if it's the entry point.
      // However, for subcommands, we need .command().
      // For the root command itself, we might want to define action if it has no subcommands or if we want a default action.
      
      // Let's assume root command is the program itself.
      // Subcommands are added to it.
      
      if (cmdId === rootId) {
          // Root command configuration (already done name/desc)
          // Add root arguments using .argument()
          const args = cmd.parameters.filter(p => p.kind === 'argument');
          args.forEach(arg => {
            const argDef = arg.required ? `<${arg.name}>` : `[${arg.name}]`;
            const desc = arg.description || '';
            content += `  program.argument('${argDef}', '${desc}');\n`;
          });
          
          // Add root options
          addParams(cmd, 'program');
          
          // If root has handler, add action
          // We allow root action even if there are subcommands, so that root options can be handled.
          // Commander.js will only trigger this action if no subcommand is matched.
          if (cmd.handlerName) {
             addAction(cmd, 'program');
          }
          
          // Process children
          cmd.subcommands.forEach(childId => buildCommand(childId, 'program'));
      } else {
          const varName = `cmd_${cmd.id.replace(/-/g, '_')}`;
          
          // Define command without inline arguments
          content += `  const ${varName} = ${parentVar}.command('${cmd.name}');\n`;
          if (cmd.description) {
              content += `  ${varName}.description('${cmd.description}');\n`;
          }
          
          // Add arguments using .argument()
          const args = cmd.parameters.filter(p => p.kind === 'argument');
          args.forEach(arg => {
            const argDef = arg.required ? `<${arg.name}>` : `[${arg.name}]`;
            const desc = arg.description || '';
            content += `  ${varName}.argument('${argDef}', '${desc}');\n`;
          });
          
          // Add options
          addParams(cmd, varName);
          
          if (cmd.handlerName) {
              addAction(cmd, varName);
          }
          
          cmd.subcommands.forEach(childId => buildCommand(childId, varName));
          content += `\n`;
      }
  };

  const addParams = (cmd: Command, varName: string) => {
      cmd.parameters.filter(p => p.kind === 'option').forEach(p => {
          const flags = `-${p.shortAlias || p.name.charAt(0)}, --${p.name} ${p.type === 'boolean' ? '' : `<${p.type}>`}`;
          const desc = p.description || '';
          const required = p.required ? '' : ''; // Commander handles required differently, usually .requiredOption
          // Simple option for now
          content += `  ${varName}.option('${flags}', '${desc}');\n`;
      });
  };

  const addAction = (cmd: Command, varName: string) => {
      // Construct params object
      // Commander passes args first, then options object, then command object.
      // We need to map these to our Params interface.
      const args = cmd.parameters.filter(p => p.kind === 'argument');
      const argNames = args.map(p => toCamelCase(p.name));
      const actionArgs = [...argNames, 'options'].join(', ');
      
      content += `  ${varName}.action(async (${actionArgs}) => {\n`;
      
      // Add validation for required arguments
      const requiredArgs = args.filter(a => a.required);
      if (requiredArgs.length > 0) {
        requiredArgs.forEach(arg => {
          const name = toCamelCase(arg.name);
          content += `    if (!${name}) {\n`;
          content += `      console.error('‚ùå Error: Required argument "${arg.name}" is missing');\n`;
          content += `      console.error('\\nUsage: ${cmd.name} <${arg.name}>');\n`;
          content += `      process.exit(1);\n`;
          content += `    }\n`;
        });
      }
      
      // Add validation for required options
      const requiredOpts = cmd.parameters.filter(p => p.kind === 'option' && p.required);
      if (requiredOpts.length > 0) {
        requiredOpts.forEach(opt => {
          const name = toCamelCase(opt.name);
          content += `    if (options.${name} === undefined) {\n`;
          content += `      console.error('‚ùå Error: Required option "--${opt.name}" is missing');\n`;
          content += `      process.exit(1);\n`;
          content += `    }\n`;
        });
      }

      // Add validation for number types
      const numberParams = cmd.parameters.filter(p => p.type === 'number');
      if (numberParams.length > 0) {
        numberParams.forEach(p => {
          const name = toCamelCase(p.name);
          const valToCheck = p.kind === 'argument' ? name : `options.${name}`;
          
          content += `    if (${valToCheck} !== undefined && isNaN(Number(${valToCheck}))) {\n`;
          content += `      console.error('‚ùå Error: ${p.kind === 'argument' ? 'Argument' : 'Option'} "${p.name}" must be a number');\n`;
          content += `      process.exit(1);\n`;
          content += `    }\n`;
        });
      }
      
      content += `    const params = {\n`;
      
      // Map arguments
      args.forEach(p => {
          const name = toCamelCase(p.name);
          const val = p.type === 'number' ? `Number(${name})` : name;
          content += `      ${name}: ${val},\n`;
      });
      
      // Map options
      cmd.parameters.filter(p => p.kind === 'option').forEach(p => {
          const name = toCamelCase(p.name);
           const val = p.type === 'number' ? `Number(options.${name})` : `options.${name}`;
           content += `      ${name}: ${val},\n`;
      });
      
      content += `    };\n`;
      content += `    await handler.${cmd.handlerName}(params);\n`;
      content += `  });\n`;
  };

  buildCommand(rootId, 'program');

  content += `  return program;\n}\n`;
  return content;
}

// Helpers
function toCamelCase(str: string) {
  return str.replace(/[-_](\w)/g, (_, c) => c.toUpperCase());
}

function toPascalCase(str: string) {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

function generateHandlerImplementation(commands: Record<string, Command>): string {
  let content = `/**
 * This file is auto-generated by CLI Maker.
 * 
 * This is a DUMMY IMPLEMENTATION for testing purposes.
 * Replace the implementation with your actual business logic.
 */

import { AppHandler } from './interfaces.js';
import * as Types from './types.js';

export class DummyHandler implements AppHandler {
`;

  Object.values(commands).forEach((cmd) => {
    if (!cmd.handlerName) return;
    const paramType = `Types.${toPascalCase(cmd.name)}Params`;
    
    content += `  async ${cmd.handlerName}(params: ${paramType}): Promise<void> {
    console.log('\\n${'='.repeat(60)}');
    console.log('üöÄ Command: ${cmd.name}');
    console.log('üìç Handler: ${cmd.handlerName}');
    console.log('${'='.repeat(60)}');
    console.log('üì¶ Parameters:');
    console.log(JSON.stringify(params, null, 2));
    console.log('${'='.repeat(60)}');
    
    // TODO: Implement your business logic here
    // This is a dummy implementation for testing
    
    console.log('‚úÖ Command executed successfully (dummy implementation)');
    console.log('');
    console.log('üí° Next steps:');
    console.log('   - Implement business logic in src/handler.ts');
    console.log('   - Replace this dummy output with actual functionality');
    console.log('${'='.repeat(60)}\\n');
  }

`;
  });

  content += `}\n`;
  return content;
}

function generateIndexFile(rootCommand: Command): string {
  return `#!/usr/bin/env node
/**
 * This file is auto-generated by CLI Maker.
 * Do not edit manually.
 */

import { setupCLI } from './cli.js';
import { DummyHandler } from './handler.js';

async function main() {
  const handler = new DummyHandler();
  const program = setupCLI(handler);
  
  await program.parseAsync(process.argv);
}

main().catch((error) => {
  console.error('Error:', error);
  process.exit(1);
});
`;
}

function generatePackageJson(rootCommand: Command): string {
  const packageJson = {
    name: rootCommand.name || 'generated-cli',
    version: '0.0.1',
    description: rootCommand.description || 'CLI generated by CLI Maker',
    type: 'module',
    main: 'dist/index.js',
    bin: {
      [rootCommand.name || 'cli']: './dist/index.js'
    },
    scripts: {
      dev: 'tsx src/index.ts',
      build: 'tsc',
      start: 'node dist/index.js',
      clean: 'rm -rf dist'
    },
    keywords: ['cli', 'commander'],
    author: '',
    license: 'MIT',
    dependencies: {
      commander: '^12.0.0'
    },
    devDependencies: {
      '@types/node': '^20.0.0',
      typescript: '^5.0.0',
      tsx: '^4.0.0'
    }
  };

  return JSON.stringify(packageJson, null, 2) + '\n';
}

function generateTsConfig(): string {
  const tsconfig = {
    compilerOptions: {
      target: 'ES2022',
      module: 'ESNext',
      lib: ['ES2022'],
      moduleResolution: 'node',
      outDir: './dist',
      rootDir: './src',
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      resolveJsonModule: true,
      declaration: true,
      declarationMap: true,
      sourceMap: true
    },
    include: ['src/**/*'],
    exclude: ['node_modules', 'dist']
  };

  return JSON.stringify(tsconfig, null, 2) + '\n';
}

function generateReadme(commands: Record<string, Command>, rootCommand: Command): string {
  const cliName = rootCommand.name || 'cli';
  
  let content = `# ${cliName}

${rootCommand.description || 'CLI application generated by CLI Maker'}

## üìã Table of Contents
- [Quick Start](#-quick-start)
- [Command Reference](#-command-reference)
- [Development Guide](#-development-guide)
- [Project Structure](#-project-structure)
- [Next Steps](#-next-steps)

## üöÄ Quick Start

### Installation

\`\`\`bash
npm install
\`\`\`

### Development Mode (TypeScript)

Run commands directly without building:

\`\`\`bash
npm run dev -- [command] [args] [options]
\`\`\`

### Production Build

Build and run the compiled version:

\`\`\`bash
npm run build
npm start -- [command] [args] [options]
\`\`\`

## üìñ Command Reference

`;

  // Generate command documentation
  const commandList = Object.values(commands).filter(cmd => cmd.id !== rootCommand.id);
  
  if (commandList.length > 0) {
    commandList.forEach(cmd => {
      content += `### \`${cmd.name}\`\n\n`;
      if (cmd.description) {
        content += `${cmd.description}\n\n`;
      }
      
      // Arguments
      const args = cmd.parameters.filter(p => p.kind === 'argument');
      if (args.length > 0) {
        content += `**Arguments:**\n\n`;
        args.forEach(arg => {
          const required = arg.required ? '(required)' : '(optional)';
          content += `- \`${arg.name}\` ${required} - ${arg.description || `${arg.type} value`}\n`;
        });
        content += '\n';
      }
      
      // Options
      const opts = cmd.parameters.filter(p => p.kind === 'option');
      if (opts.length > 0) {
        content += `**Options:**\n\n`;
        opts.forEach(opt => {
          const required = opt.required ? '(required)' : '(optional)';
          const shortAlias = opt.shortAlias ? `-${opt.shortAlias}, ` : '';
          content += `- \`${shortAlias}--${opt.name}\` ${required} - ${opt.description || `${opt.type} value`}\n`;
        });
        content += '\n';
      }
      
      // Example
      const exampleArgs = args.map(a => a.required ? `<${a.name}>` : `[${a.name}]`).join(' ');
      const exampleOpts = opts.slice(0, 1).map(o => `--${o.name} <value>`).join(' ');
      const example = [cmd.name, exampleArgs, exampleOpts].filter(Boolean).join(' ');
      
      content += `**Example:**\n\n\`\`\`bash\nnpm run dev -- ${example}\n\`\`\`\n\n`;
    });
  } else {
    content += `No subcommands defined. This CLI has a single root command.\n\n`;
  }

  content += `## üõ†Ô∏è Development Guide

### Implementing Business Logic

The current implementation in \`src/handler.ts\` is a **dummy implementation** for testing purposes.

To add your actual business logic:

1. Open \`src/handler.ts\`
2. Find the handler method you want to implement (e.g., \`${commandList[0]?.handlerName || 'handleCommand'}\`)
3. Replace the dummy console.log statements with your actual logic
4. The \`params\` object contains all parsed arguments and options with proper types

**Example:**

\`\`\`typescript
async ${commandList[0]?.handlerName || 'handleCommand'}(params: Types.${toPascalCase(commandList[0]?.name || 'Command')}Params): Promise<void> {
  // Your actual implementation here
  // params is fully typed based on your CLI definition
  
  // Example: Make API calls, file operations, etc.
  const result = await someAsyncOperation(params);
  console.log('Result:', result);
}
\`\`\`

### Adding Error Handling

\`\`\`typescript
async ${commandList[0]?.handlerName || 'handleCommand'}(params: Types.${toPascalCase(commandList[0]?.name || 'Command')}Params): Promise<void> {
  try {
    // Your logic here
  } catch (error) {
    console.error('Error:', error instanceof Error ? error.message : error);
    throw error; // Re-throw to let CLI handle it
  }
}
\`\`\`

## üìÅ Project Structure

\`\`\`
.
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ types.ts          # TypeScript type definitions for parameters
‚îÇ   ‚îú‚îÄ‚îÄ interfaces.ts     # AppHandler interface definition
‚îÇ   ‚îú‚îÄ‚îÄ cli.ts           # CLI setup using Commander.js
‚îÇ   ‚îú‚îÄ‚îÄ handler.ts       # Handler implementation (EDIT THIS)
‚îÇ   ‚îî‚îÄ‚îÄ index.ts         # Entry point
‚îú‚îÄ‚îÄ dist/                # Compiled JavaScript (after build)
‚îú‚îÄ‚îÄ package.json         # Project configuration
‚îú‚îÄ‚îÄ tsconfig.json        # TypeScript configuration
‚îî‚îÄ‚îÄ README.md           # This file
\`\`\`

## üéØ Next Steps

- [ ] Implement business logic in \`src/handler.ts\`
- [ ] Add error handling for edge cases
- [ ] Add unit tests (optional)
- [ ] Update this README with your specific documentation
- [ ] Configure CI/CD if needed
- [ ] Publish to npm (optional)

## üîß Troubleshooting

### Command not found

Make sure you've run \`npm install\` first.

### TypeScript errors

Run \`npm run build\` to see detailed TypeScript errors.

### Permission denied

If you get permission errors when running the built CLI:

\`\`\`bash
chmod +x dist/index.js
\`\`\`

---

**Generated by [CLI Maker](https://github.com/yourusername/cli-maker)**
`;

  return content;
}

function generateGitignore(): string {
  return `# Dependencies
node_modules/

# Build output
dist/

# Environment variables
.env
.env.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Testing
coverage/
`;
}
